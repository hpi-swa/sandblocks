"
A SBBlock is the central element of Sandblocks.

It is an abstract superclass offering sensible default behavior for most interactions with other blocks.
"
Class {
	#name : #SBBlock,
	#superclass : #Morph,
	#instVars : [
		'decorators',
		'colorPolicyCache'
	],
	#classVars : [
		'Navigation'
	],
	#category : #'Sandblocks-Core'
}

{ #category : #'as yet unclassified' }
SBBlock class >> attractionStrengthMultiplier [

	^ 0.6
]

{ #category : #'as yet unclassified' }
SBBlock class >> defaultRepelStrength [

	^ 5000.0
]

{ #category : #'as yet unclassified' }
SBBlock class >> implicitAttractionStrength [

	^ 0.25
]

{ #category : #'as yet unclassified' }
SBBlock class >> maxRepelDistance [

	^ 100
]

{ #category : #'as yet unclassified' }
SBBlock class >> maximumNonOverlappingForce [

	^ 10
]

{ #category : #'as yet unclassified' }
SBBlock class >> navigation [

	^ Navigation ifNil: [Navigation := SBSmalltalkNavigation new]
]

{ #category : #'as yet unclassified' }
SBBlock class >> navigation: aNavigation [

	Navigation := aNavigation
]

{ #category : #input }
SBBlock >> absorbsInput: anEvent [
	" a chance for you to block this event from being dispatched as shortcut "

	^ false
]

{ #category : #'action helpers' }
SBBlock >> actionProviders [

	^ {self}, self decorators
]

{ #category : #'action helpers' }
SBBlock >> actions [

	^ (Array streamContents: [:stream |
		self actionProviders do: [:obj |
			obj class withAllSuperclassesDo: [:class |
				Pragma
					withPragmasIn: class
					do: [:pragma | (#(#action #multiSelectAction #inputAction) includes: pragma keyword) ifTrue: [stream nextPut: pragma]]]]]) asIdentitySet asArray
]

{ #category : #accessing }
SBBlock >> activeTextMorph [

	| candidate |
	candidate := self sandblockEditor currentInputCommand ifNotNil: #textMorph.
	candidate ifNil: [^ nil].
	(self textMorphs includes: candidate) ifFalse: [^ nil].
	^ candidate
]

{ #category : #hierarchy }
SBBlock >> addBlock: aBlock [

	(self insertCommandRequest: aBlock near: nil before: false) do
]

{ #category : #'as yet unclassified' }
SBBlock >> allBlocksDetect: aBlock [

	^ self allBlocksDetect: aBlock ifFound: [:b | b] ifNone: [self error: 'no such block']
]

{ #category : #hierarchy }
SBBlock >> allBlocksDetect: aBlock ifFound: aSuccessBlock ifNone: aFailureBlock [

	self allBlocksDo: [:b | (aBlock value: b) ifTrue: [^ aSuccessBlock value: b]].
	^ aFailureBlock value
]

{ #category : #hierarchy }
SBBlock >> allBlocksDo: aBlock [

	self childSandblocksDo: [:m | m allBlocksDo: aBlock].
	aBlock value: self
]

{ #category : #hierarchy }
SBBlock >> allBlocksFor: anObject withInterfaces: aCollection [

	^ Array streamContents: [:stream |
		self allBlocksDo: [:morph |
			(morph isSandblock and: [morph object = anObject and: [morph satisfies: aCollection]]) ifTrue: [stream nextPut: morph]]]
]

{ #category : #'as yet unclassified' }
SBBlock >> allBlocksSatisfy: aBlock [

	self allBlocksDo: [:b | (aBlock value: b) ifFalse: [^ false]].
	^ true
]

{ #category : #hierarchy }
SBBlock >> allBlocksSelect: aBlock [

	^ Array streamContents: [:stream | self allBlocksDo: [:b | (aBlock value: b) ifTrue: [stream nextPut: b]]]
]

{ #category : #'as yet unclassified' }
SBBlock >> allChildBlocksSatisfy: aBlock [

	self allBlocksDo: [:b | (b ~= self and: [(aBlock value: b) not]) ifTrue: [^ false]].
	^ true
]

{ #category : #connections }
SBBlock >> allConnections [

	^ Array streamContents: [:stream | self allConnectionsDo: [:each | stream nextPut: each]]
]

{ #category : #connections }
SBBlock >> allConnectionsDo: aBlock [

	self flag: #todo.
	"considers only blocks that share the same container"
	self owner ifNotNil: [self owner submorphsDo: [:m | (m isConnector and: [m to = self or: [m from = self]]) ifTrue: [aBlock value: m]]]
]

{ #category : #hierarchy }
SBBlock >> andAllParentSandblocksDo: aBlock [

	aBlock value: self.
	self parentSandblock ifNotNil: [:p | p andAllParentSandblocksDo: aBlock]
]

{ #category : #'as yet unclassified' }
SBBlock >> appendElement [
	<action>

	| cmd |
	cmd := (self
		insertEmptyCommandRequestNear: nil
		before: false) ifNil: [^ self].
	
	self sandblockEditor do: cmd.
	
	cmd shouldMergeWithNext ifTrue: [
		self sandblockEditor
			startInput: self sandblockEditor selection
			at: 0
			replacingContents: false]
]

{ #category : #layout }
SBBlock >> applyUserInterfaceTheme [

	super applyUserInterfaceTheme.
	
	self layoutChanged
]

{ #category : #callbacks }
SBBlock >> artefactChanged: aMethodBlock [
	" callback fired after each change to a method "

	
]

{ #category : #suggestions }
SBBlock >> artefactCompletionSelectorsFor: aBlock class: aClass [
	"May be overridden by subclasses."
	
	aClass ifNil: [^ Symbol allSymbols].
	
	^ aClass sandblocksSuggestionsFor: self
]

{ #category : #accessing }
SBBlock >> artefactForPersisting [

	| candidate |
	candidate := self containingArtefact.
	[candidate isNil or: [candidate canPersist]] whileFalse: [candidate := candidate parentSandblock ifNotNil: #containingArtefact].
	^ candidate
]

{ #category : #callbacks }
SBBlock >> artefactSaved: aMethodBlock [

	" callback fired after each save of a method/artefact "
]

{ #category : #converting }
SBBlock >> asSandblock [

	^ self
]

{ #category : #converting }
SBBlock >> asThumbnail: converter [
	<convert>
	
	converter
		if: [self sandblockEditor notNil]
		do: [self thumbnail]
]

{ #category : #decorators }
SBBlock >> attachDecorator: aDecorator [

	decorators add: aDecorator.
	aDecorator attached: self.
	self changed.
	self updateSteppingDecorators
]

{ #category : #'dropping/grabbing' }
SBBlock >> attachToHand: aHand in: anEditor [

	| s |
	s := SBSelection new
		homeArtefact: self containingArtefact;
		methodClass: (self containingArtefact ifNotNil: #relatedClass);
		colorPolicy: anEditor colorPolicy;
		sourceBlock: self;
		yourself.
	
	self containingBlock ifNotNil: [:b | (b sandblockBlockColorIfAbsent: [nil]) ifNotNil: [:c | s color: c]].
	
	s addMorphBack: self dragTarget.
	aHand grabMorph: s
]

{ #category : #'as yet unclassified' }
SBBlock >> attractionStrengthTo: aMorph [

	^ (self isAttractedTo: aMorph)
		ifTrue: [self class implicitAttractionStrength]
		ifFalse: [0.0]
]

{ #category : #'as yet unclassified' }
SBBlock >> attractionTo: aMorph [

	^ (self attractionStrengthTo: aMorph) + (aMorph attractionStrengthTo: self)
	
	
]

{ #category : #'as yet unclassified' }
SBBlock >> backspaceShouldUnwrapTo: aBlock [

	^ aBlock floating not and: [
		aBlock parentSandblock ~= self sandblockEditor and: [ | num |
			"check how many blocks would disappear and only allow if it's a small number"
			num := 0.
			aBlock allBlocksDo: [:b | num := num + 1].
			num < 4]]
]

{ #category : #actions }
SBBlock >> barf [
	<action>
	<actionValidIf: #parentHasDynamicNumberOfChildren>

	
	self hasChildSandblocks ifFalse: [^ self].
	
	self sandblockEditor do: (self parentSandblock insertCommandRequest: self childSandblocks last near: self before: false).
	self select
]

{ #category : #actions }
SBBlock >> barfFront [
	<action>
	<actionValidIf: #parentHasDynamicNumberOfChildren>

	
	self hasChildSandblocks ifFalse: [^ self].
	
	self sandblockEditor do: (self parentSandblock insertCommandRequest: self childSandblocks first near: self before: true).
	self select
]

{ #category : #'event handling' }
SBBlock >> batchedChangeStep [

	self sandblockEditor ifNotNil: [:e | e batchedChangeStep: self]
]

{ #category : #'ast helpers' }
SBBlock >> binding: aString for: block class: aClass ifPresent: aBlock [

	^ self parentSandblock ifNotNil: [:p | p binding: aString for: block class: aClass ifPresent: aBlock]
]

{ #category : #'ast helpers' }
SBBlock >> bindingOf: aString [

	^ self parentSandblock ifNotNil: [:p | p bindingOf: aString]
]

{ #category : #hierarchy }
SBBlock >> blockFor: anObject withInterfaces: aCollection ifOpen: aBlock ifClosed: anotherBlock [

	^ self
		allBlocksDetect: [:morph | morph isSandblock and: [morph object == anObject and: [morph satisfies: aCollection]]]
		ifFound: aBlock
		ifNone: anotherBlock
]

{ #category : #actions }
SBBlock >> browse [
	<action>
	" you were asked to be browsed. you may ignore this "

	self relatedClass browse
]

{ #category : #testing }
SBBlock >> canAppearInBlockBody [

	^ self isExpression
]

{ #category : #testing }
SBBlock >> canCopy [

	^ true
]

{ #category : #'actions tests' }
SBBlock >> canDelete [

	^ (self parentSandblock deleteCommandFor: self) notNil
]

{ #category : #'insert/delete' }
SBBlock >> canDeleteChild: aBlock [

	^ self fixedNumberOfChildren not
]

{ #category : #accessing }
SBBlock >> canDrag [

	^ self valueOfProperty: #canDrag ifAbsent: [true]
]

{ #category : #accessing }
SBBlock >> canDrag: aBoolean [

	self setProperty: #canDrag toValue: aBoolean
]

{ #category : #testing }
SBBlock >> canEvaluate [

	^ false
]

{ #category : #'actions tests' }
SBBlock >> canInput [

	self flag: #fixme.
	" see if we specialize startInput. FIXME: we can currently not just call startInput and
	see what we get back because some classes cause side-effects, which they shouldn't "
	"(self class lookupSelector: #startInputAt:replacingContents:) methodClass ~= SBBlock"
	
	^ self currentTextMorph notNil
]

{ #category : #'actions tests' }
SBBlock >> canInsertAfter [

	^ (self parentSandblock insertEmptyCommandRequestNear: self before: false) notNil
]

{ #category : #'actions tests' }
SBBlock >> canInsertBefore [

	^ (self parentSandblock insertEmptyCommandRequestNear: self before: true) notNil
]

{ #category : #'actions tests' }
SBBlock >> canJumpTo: aBlock [

	aBlock parentSandblock ifNil: [^ false].
	
	^ aBlock parentSandblock containingArtefact = self containingArtefact or: [self containingArtefact notNil and: [self containingArtefact floating not]]
]

{ #category : #testing }
SBBlock >> canPersist [

	^ true
]

{ #category : #'colors and color policies' }
SBBlock >> centerAlignSymbols [

	^ true
]

{ #category : #actions }
SBBlock >> changeLocalColorPolicy [
	<action>

	^ (UIManager default
		chooseFrom: (SBColorPolicy withAllSubclasses collect: #asString)
		values: SBColorPolicy withAllSubclasses) ifNotNil: [:policy | self localColorPolicy: policy new]
]

{ #category : #actions }
SBBlock >> changeToUnknown [
	<action>

	self newNullBlock convertedFor: self objectInterface do: [:new |
		new ifNotNil: [
			self sandblockEditor
				do: (SBReplaceCommand new
					target: self;
					replacer: new;
					shouldMergeWithNext: true;
					yourself);
				startInput: new at: 0 replacingContents: false]]
]

{ #category : #hierarchy }
SBBlock >> childClosestTo: aPoint that: aBlock [

	| closestDistance closestMorph |
	closestDistance := 900000000.
	closestMorph := nil.
	self childSandblocksDo: [:block | | distance |
		(aBlock value: block) ifTrue: [
			distance := block topLeft squaredDistanceTo: aPoint.
			distance < closestDistance ifTrue: [
				closestDistance := distance.
				closestMorph := block]]].
	^ closestMorph
]

{ #category : #hierarchy }
SBBlock >> childHierarchyComplexity [

	^ self childSandblocks size < 2 ifTrue: [0] ifFalse: [ | c |
		c := 0.
		self allBlocksDo: [:b | c := c + 1].
		c]
]

{ #category : #hierarchy }
SBBlock >> childIndex [

	^ self parentSandblock childSandblocks indexOf: self
]

{ #category : #caching }
SBBlock >> clearCache [
	" this block may have just been duplicated or moved somewhere else, ensure to clear all caches and present yourself neatly "

	self layoutChanged.
	self clearCacheSelf.
	super clearCache
]

{ #category : #caching }
SBBlock >> clearCacheSelf [

	colorPolicyCache := nil.
	self removeProperty: #sandblockBlockColor.
	self removeProperty: #foregroundColorCache.
	self removeProperty: #colorCache
]

{ #category : #actions }
SBBlock >> clearInput [
	<action>

	(self hasCurrentTextMorph and: [self hasInput])
		ifTrue: [
			SBToggledCode comment: '' active: 1 do: {
				[(self sandblockEditor currentInputCommand ifNotNil: #textMorph) contents: ''].
				[
					self sandblockEditor
						startInput: self
						at: 1
						replacingContents: true
						in: self sandblockEditor cursor cursorPosition textMorph]}]
		ifFalse: [self changeToUnknown]
]

{ #category : #'event handling' }
SBBlock >> click: anEvent [

	(anEvent redButtonPressed and: [anEvent shiftPressed]) ifTrue: [^ self startOrAddToMultiSelection].
	
	self sandblockEditor selectClick: self at: anEvent position.
	(anEvent yellowButtonPressed and: [SBPreferences rightClickContextMenu]) ifTrue: [self promptAction].
	(self isInWorld and: [self suggestAlways and: [anEvent redButtonPressed]]) ifTrue: [self queueUpdateSuggestionsFocused: self isOneStatementPerArtefact]
]

{ #category : #hierarchy }
SBBlock >> closestAdjacentFrom: mySide to: theirSide [

	| myPoint direction component candidates |
	SBToggledCode
		comment: 'center is likely more permissive, but mySide might be more accurate'
		active: 1
		do: {[myPoint := self perform: mySide]. [myPoint := self center]}.
	direction := ({#leftCenter. #topCenter} includes: mySide) ifTrue: [#<] ifFalse: [#>].
	component := ({#leftCenter. #rightCenter} includes: mySide) ifTrue: [#x] ifFalse: [#y].
	candidates := self parentSandblock childSandblocks select: [:block |
		block ~= self and: [
			((block perform: mySide) perform: component) perform: direction with: (myPoint perform: component)]].
	^ candidates
		ifEmpty: [self]
		ifNotEmpty: [
			candidates fold: [:a :b |
				((a perform: theirSide) squaredDistanceTo: myPoint) < ((b perform: theirSide) squaredDistanceTo: myPoint) ifTrue: [a] ifFalse: [b]]]
]

{ #category : #'colors and color policies' }
SBBlock >> color [

	^ self
		valueOfProperty: #colorCache
		ifAbsentPut: [self colorPolicy ifNotNil: [:p | p colorForBlock: self] ifNil: [Color r: 1 g: 1 b: 1]]
]

{ #category : #'colors and color policies' }
SBBlock >> colorPolicy [

	^ colorPolicyCache ifNil: [
		self valueOfProperty: #localColorPolicy ifPresentDo: [:c | ^ colorPolicyCache := c].
		self parentSandblock ifNotNil: [:p | colorPolicyCache := p colorPolicy] ifNil: [SBDefaultColorPolicy new]]
]

{ #category : #testing }
SBBlock >> completeSubtree [

	self allBlocksDo: [:b | b isUnknown ifTrue: [^ false]].
	^ true
]

{ #category : #connections }
SBBlock >> connectedBlocks [
	"all blocks on the ends of *outoing* connections"

	^ Array streamContents: [:stream | self outgoingConnectionsDo: [:m | stream nextPut: m to]]
]

{ #category : #accessing }
SBBlock >> containingArtefact [

	^ self isArtefact
		ifTrue: [self]
		ifFalse: [self parentSandblock ifNotNil: [:b | b containingArtefact]]
]

{ #category : #hierarchy }
SBBlock >> containingBlock [

	| next |
	next := self.
	[next := next parentSandblock ifNil: [^ nil]] doWhileFalse: [next isBlockBody].
	^ next
]

{ #category : #hierarchy }
SBBlock >> containingBlocksDo: aBlock [

	| current |
	current := self containingBlock.
	[current] whileNotNil: [
		aBlock value: current.
		current := current containingBlock]
]

{ #category : #hierarchy }
SBBlock >> containingFloat [

	self floating ifTrue: [^ self].
	
	^ (self ownerSatisfying: [:o | o isSandblock and: [o floating]]) ifNil: [self sandblockEditor]
]

{ #category : #hierarchy }
SBBlock >> containingSandblock [

	^ self
]

{ #category : #hierarchy }
SBBlock >> containingStatement [

	| parent |
	parent := self parentSandblock.
	parent ifNil: [^ nil].
	
	(parent isBlockBody and: [parent statements includes: self]) ifTrue: [^ self].
	^ parent containingStatement
]

{ #category : #hierarchy }
SBBlock >> containingToplevel [
	" first parent that is floating "
	
	^ self floating ifTrue: [self] ifFalse: [self parentSandblock containingToplevel]
]

{ #category : #accessing }
SBBlock >> contents [

	^ self currentTextMorph ifNotNil: [:t | t contents]
]

{ #category : #accessing }
SBBlock >> contents: aString [

	self currentTextMorph ifNotNil: [:t | t contents: aString]
]

{ #category : #'as yet unclassified' }
SBBlock >> continueInput [

	(self startInputCommand
		ifNotNil: [self]
		ifNil: [self nextBlockThat: [:m | m startInputCommand notNil]]) ifNotNil: [:m | ((m hasOwner: self) or: [m = self]) ifTrue: [self sandblockEditor startInput: m at: 900000000 replacingContents: false]]
]

{ #category : #actions }
SBBlock >> convertTo [
	<action>

	| options index |
	options := Array streamContents: [:stream | self object allConversionsFor: self objectInterface do: [:pair | stream nextPut: pair]].
	options ifEmpty: [^ self].
	
	index := UIManager default chooseFrom: (options collect: #first).
	index > 0 ifTrue: [
		self sandblockEditor do: (SBReplaceCommand new
			target: self;
			replacer: (options at: index) second)]
]

{ #category : #actions }
SBBlock >> copyAround [
	<action>

	| editor target |
	" create a copy of our surroundings with ourselves replaced "
	editor := self sandblockEditor.
	target := self parentSandblock.
	editor countModifier - 1 timesRepeat: [target := target parentSandblock].
	
	self setProperty: #copyPlaceholder toValue: true.
	editor copyBuffer: target.
	self removeProperty: #copyPlaceholder
]

{ #category : #copying }
SBBlock >> copyBlock [

	^ self veryDeepCopy
]

{ #category : #'ast helpers' }
SBBlock >> copyFindSelection: aBlock in: aParentBlock [

	| index |
	"assume we are an exact copy of aParentBlock and aBlock is a child of aParentBlock
this method returns our child that corresponds to aBlock"
	index := 0.
	aParentBlock allBlocksDo: [:b |
		b = aBlock ifTrue: [
			self allBlocksDo: [:b2 |
				index = 0 ifTrue: [^ b2].
				index := index - 1]].
		index := index + 1].
	self error: 'block could not be found again'
]

{ #category : #testing }
SBBlock >> copyOnDrag [
	" return true if you always want to copy when drags are started "

	^ false
]

{ #category : #'insert/delete' }
SBBlock >> copyPlaceholder [

	self allMorphsDo: [:m | (m valueOfProperty: #copyPlaceholder ifAbsent: [false]) ifTrue: [^ m]].
	^ nil
]

{ #category : #actions }
SBBlock >> copyString [
	<action>

	Clipboard clipboardText: self textContentsForCopy
]

{ #category : #actions }
SBBlock >> copyToBuffer [
	<multiSelectAction>

	self sandblockEditor copyBuffer: self sandblockEditor multiSelection.
	self performAction: #copyString.
	self sandblockEditor endMultiSelection
]

{ #category : #accessing }
SBBlock >> currentTextMorph [

	^ nil
]

{ #category : #cursor }
SBBlock >> cursorPositionAfterThat: aBlock [

	self cursorPositionsAfterDo: [:pos | (aBlock value: pos) ifTrue: [^ pos]].
	^ nil
]

{ #category : #cursor }
SBBlock >> cursorPositionBeforeThat: aBlock [

	| last |
	last := nil.
	self containingFloat cursorPositionsDo: [:pos |
		pos block = self ifTrue: [^ last].
		(aBlock value: pos) ifTrue: [last := pos]].
	^ last
]

{ #category : #cursor }
SBBlock >> cursorPositionInSelfOrAfterThat: aBlock [

	self cursorPositionsInSelfOrAfterDo: [:pos | (aBlock value: pos) ifTrue: [^ pos]].
	^ nil
]

{ #category : #cursor }
SBBlock >> cursorPositionsAfterDo: aBlock [

	| found |
	found := false.
	self containingFloat cursorPositionsDo: [:pos |
		pos block = self ifTrue: [found := true].
		(found and: [pos block ~= self and: [(pos block hasOwner: self) not]]) ifTrue: [aBlock value: pos]]
]

{ #category : #cursor }
SBBlock >> cursorPositionsInSelfOrAfterDo: aBlock [

	| found |
	found := false.
	self containingFloat cursorPositionsDo: [:pos |
		pos block = self ifTrue: [found := true].
		found ifTrue: [aBlock value: pos]]
]

{ #category : #'ast helpers' }
SBBlock >> declarationsDo: aBlock [

	
]

{ #category : #decorators }
SBBlock >> decorators [

	^ decorators
]

{ #category : #actions }
SBBlock >> deleteAdjacent [
	<action>

	| count startIndex endIndex targets |
	count := self sandblockEditor countModifier.
	
	startIndex := self childIndex.
	endIndex := count = 0
		ifTrue: [self parentSandblock childSandblocks size]
		ifFalse: [startIndex + (count - 1) min: self parentSandblock childSandblocks size].
	
	targets := (startIndex to: endIndex) collect: [:index | self parentSandblock childSandblocks at: index].
	
	self sandblockEditor do: (SBCombinedCommand newWith: (targets collect: [:target | SBDeleteCommand new target: target]))
]

{ #category : #actions }
SBBlock >> deleteAfterCursor [
	<inputAction>
	<actionValidIf: #hasCurrentTextMorph>
	
	self currentTextMorph deleteAfterCursor
]

{ #category : #actions }
SBBlock >> deleteAround [
	<action>

	| editor |
	self example: ['3 squared' parseInMethod receiver] args: [{}] label: 'example'.
	editor := self sandblockEditor.
	self
		deleteAroundTargetDo: [:target :replacer |
			self setProperty: #copyPlaceholder toValue: true.
			editor copyBuffer: target preferQuick: true.
			self removeProperty: #copyPlaceholder.
			editor do: (SBReplaceCommand new
				selectAfter: #block;
				target: target;
				replacer: replacer).
			replacer postDuplicate.
			^ self]
		ifNone: []
]

{ #category : #'action helpers' }
SBBlock >> deleteAroundTargetDo: aBlock ifNone: anotherBlock [

	| target |
	target := self parentSandblock.
	[
		self convertedFor: target objectInterface do: [:replacer | aBlock value: target value: replacer].
		target := target parentSandblock.
		(target isNil or: [target floating and: [target isArtefact]]) ifTrue: [^ anotherBlock value]] repeat
]

{ #category : #actions }
SBBlock >> deleteBeforeCursor [
	<inputAction>
	<actionValidIf: #hasCurrentTextMorph>

	| editor adjacent parent textMorph |
	textMorph := self sandblockEditor currentInputCommand textMorph.
	textMorph cursor ~= 1 ifTrue: [
		textMorph deleteBeforeCursor.
		self updateSuggestions.
		^ self batchedChangeStep].
	self symbols first notNil ifTrue: [
		editor := self sandblockEditor.
		" try and change to unknown. if no change occurred, delete "
		self changeToUnknown.
		editor selection class = self class ifTrue: [editor selection deleteBlock].
		^ self].
	
	editor := self sandblockEditor.
	parent := self parentSandblock.
	
	adjacent := textMorph previousMorphThat: [:b | b isTextMorph].
	
	(adjacent notNil and: [adjacent hasOwner: parent])
		ifTrue: [ | target |
			target := adjacent containingSandblock.
			textMorph contents isEmpty ifTrue: [
				self hasChildSandblocks not
					ifTrue: [self deleteBlock]
					ifFalse: [(target = self childSandblocks first or: [target hasOwner: self childSandblocks first]) ifTrue: [self childSandblocks first deleteAround]]].
			target sandblockEditor ifNotNil: [editor startInput: target at: 900000000 replacingContents: false]]
		ifFalse: [
			(self parentHasDynamicNumberOfChildren and: [parent childSandblocks size > 1])
				ifTrue: [
					self deleteBlock.
					editor startInput: parent childSandblocks first at: 900000000 replacingContents: false]
				ifFalse: [
					self
						deleteAroundTargetDo: [:target :replacer |
							(self backspaceShouldUnwrapTo: target) ifTrue: [
								self deleteAround.
								editor startInput: self at: 900000000 replacingContents: false]]
						ifNone: []]]
]

{ #category : #actions }
SBBlock >> deleteBlock [
	<multiSelectAction>
	<actionValidIf: #canDelete>

	self isSelected ifFalse: [^ self sandblockEditor do: (self parentSandblock deleteCommandFor: self)].
	
	self sandblockEditor doMultiSelectionEach: [:selected | selected parentSandblock deleteCommandFor: selected]
]

{ #category : #actions }
SBBlock >> deleteBlockWithCopy [
	<multiSelectAction>
	<actionValidIf: #canDelete>

	| blocks editor |
	blocks := self sandblockEditor multiSelection.
	editor := self sandblockEditor.
	self deleteBlock.
	editor copyBuffer: blocks preferQuick: true
]

{ #category : #'insert/delete' }
SBBlock >> deleteCommandFor: aBlock [

	^ (self canDeleteChild: aBlock)
		ifTrue: [SBDeleteCommand new target: aBlock]
		ifFalse: [
			self newNullBlock ifNotNil: [:nullBlock |
				SBReplaceCommand new
					target: aBlock;
					replacer: nullBlock]]
]

{ #category : #callbacks }
SBBlock >> deselectedTextMorph: aMorph for: aNewPosition [

	
]

{ #category : #decorators }
SBBlock >> detachDecorator: aDecorator [

	decorators remove: aDecorator ifAbsent: [].
	self world ifNotNil: [:w | w stopStepping: aDecorator selector: #step].
	aDecorator detached: self.
	self changed
]

{ #category : #decorators }
SBBlock >> detachDecorators: aDecoratorClass [

	decorators do: [:d | d class = aDecoratorClass ifTrue: [d detached: self]].
	decorators := decorators reject: [:d | d class = aDecoratorClass].
	self changed.
	self updateSteppingDecorators
]

{ #category : #decorators }
SBBlock >> detachDecoratorsThat: aBlock [

	decorators do: [:d | (aBlock value: d) ifTrue: [d detached: self]].
	decorators := decorators reject: [:d | aBlock value: d].
	self changed.
	self updateSteppingDecorators
]

{ #category : #actions }
SBBlock >> dismiss [
	<action>

	self sandblockEditor suggestionMenu delete
]

{ #category : #'event handling' }
SBBlock >> doubleClick: evt [

	super doubleClick: evt.
	self triggerEvent: #doubleClicked
]

{ #category : #'dropping/grabbing' }
SBBlock >> dragTarget [

	^ self veryDeepCopy
]

{ #category : #drawing }
SBBlock >> drawBackgroundOn: aCanvas [

	| policy |
	policy := self colorPolicy.
	^ aCanvas
		frameAndFillRoundRect: self bounds
		radius: policy cornerRadius
		fillStyle: self drawnColor
		borderWidth: (policy borderWidthForBlock: self)
		borderColor: (policy borderColorForBlock: self)
]

{ #category : #drawing }
SBBlock >> drawChangedMarker: aCanvas [

	^ self hasUnsavedChanges ifTrue: [ | adornment |
		adornment := PluggableTextMorph adornmentWithColor: Color orange.
		aCanvas translucentImage: adornment at: self position + (self width - adornment width @ 0)]
]

{ #category : #drawing }
SBBlock >> drawDecoratorsOn: aCanvas during: aBlock [

	self decorators do: [:d | d preDrawOn: aCanvas].
	
	aBlock value.
	
	self decorators do: [:d | d postDrawSelfOn: aCanvas]
]

{ #category : #drawing }
SBBlock >> drawDropHighlightOn: aCanvas [

	
]

{ #category : #drawing }
SBBlock >> drawFrame: aColor on: aCanvas [

	aCanvas
		frameRectangle: (self bounds expandBy: 2) width: self frameSize
		color: aColor
]

{ #category : #drawing }
SBBlock >> drawInvalidBorderOn: aCanvas [

	aCanvas frameRoundRect: self bounds radius: self colorPolicy cornerRadius width: 2 color: Color red
]

{ #category : #drawing }
SBBlock >> drawOn: aCanvas [

	self drawDecoratorsOn: (self drawBackgroundOn: aCanvas) during: [self drawSymbolsOn: aCanvas]
]

{ #category : #drawing }
SBBlock >> drawSubmorphsOn: aCanvas [

	self valid ifFalse: [self drawInvalidBorderOn: aCanvas].
	super drawSubmorphsOn: aCanvas.
	
	self drawChangedMarker: aCanvas.
	
	self decorators do: [:d | d postDrawOn: aCanvas]
]

{ #category : #drawing }
SBBlock >> drawSymbolsOn: aCanvas [

	| symbols fg font space y centerAlign opacity |
	centerAlign := self colorPolicy centerAlignSymbols and: [self centerAlignSymbols].
	symbols := self symbols.
	space := self spaceForSymbols.
	font := self fontToUse.
	fg := self sandblockForegroundColor.
	opacity := self colorPolicy symbolsOpacity.
	y := centerAlign
		ifTrue: [(self layoutBounds height / 2 - (font height / 2)) rounded]
		ifFalse: [0].
	symbols first ifNotNil: [
		aCanvas
			drawString: symbols first
			at: self layoutBounds origin + (space first negated rounded @ y)
			font: font
			color: (fg alpha: opacity)].
	symbols second ifNotNil: [
		aCanvas
			drawString: symbols second
			at: self layoutBounds topRight + (0 @ (centerAlign ifTrue: [y] ifFalse: [self layoutBounds height - font height]))
			font: font
			color: (fg alpha: opacity)]
]

{ #category : #'colors and color policies' }
SBBlock >> drawnColor [

	^ self color
]

{ #category : #'testing hierarchy' }
SBBlock >> dynamicNumberOfChildren [

	^ self fixedNumberOfChildren not
]

{ #category : #actions }
SBBlock >> endInput [
	<inputAction>

	self sandblockEditor endInput
]

{ #category : #actions }
SBBlock >> endMultiSelection [
	<action>
	<actionValidIf: #hasMultiSelection>

	self sandblockEditor selectNoInput: self
]

{ #category : #decorators }
SBBlock >> ensureDecorator: aClass do: aBlock [

	decorators detect: [:d | d class = aClass] ifFound: aBlock ifNone: [| d |
		d := aClass new.
		self attachDecorator: d.
		aBlock value: d]
]

{ #category : #'artefact protocol' }
SBBlock >> ensureExpanded [
]

{ #category : #layout }
SBBlock >> ensureLayouted [

	SBToggledCode comment: '' active: 1 do: {
		[self allOwnersDo: #fullBounds].
		[self owner ifNotNil: [:o | o layoutPolicy ifNotNil: [:l | l ensureLayouted: self]]]}
]

{ #category : #actions }
SBBlock >> ensureVisible [
	<action>

	| method |
	method := self containingArtefact.
	(method ~= self and: [method notNil and: [self visibleInWorld not]]) ifTrue: [method ensureExpanded].
	
	self isInWorld ifTrue: [self sandblockEditor ifNotNil: [:e |
		e scrollToShow: (e cursor cursorPosition block = self ifTrue: [e cursor cursorPosition] ifFalse: [self])]]
]

{ #category : #actions }
SBBlock >> exploreSelf [
	<action>
	
	self sandblockEditor openMorphInView: (SBExplorer on: self)
]

{ #category : #hierarchy }
SBBlock >> firstDeepChild [

	| current |
	current := self.
	[current childSandblocks isEmpty] whileFalse: [current := current childSandblocks first].
	^ current
]

{ #category : #'ast helpers' }
SBBlock >> fixActions [

	^ #()
]

{ #category : #'testing hierarchy' }
SBBlock >> fixedNumberOfChildren [
	" return whether you may only take a fixed number of children "

	^ true
]

{ #category : #hierarchy }
SBBlock >> flattenChildren [

	self childSandblocks reverseDo: [:b | self parentSandblock addMorph: b after: self].
	self delete
]

{ #category : #testing }
SBBlock >> floating [

	^ self owner isNil or: [self owner layoutPolicy isNil or: [self owner layoutPolicy floating or: [self disableLayout]]]
]

{ #category : #accessing }
SBBlock >> focusAfterDelete: aBlock [

	" set a hint to focus aBlock when this block is deleted "
	self setProperty: #focusAfterDelete toValue: aBlock
]

{ #category : #accessing }
SBBlock >> focusAfterDeleteIfNone: aBlock [

	| block |
	block := self valueOfProperty: #focusAfterDelete ifAbsent: [^ aBlock value].
	^ block isInWorld ifTrue: [block] ifFalse: [aBlock value]
]

{ #category : #'as yet unclassified' }
SBBlock >> forceAgainst: aMorph [

	| direction |
	direction := self center - aMorph center.
	^ (direction closeTo: 0 @ 0)
		ifTrue: [(ThreadSafeRandom next @ ThreadSafeRandom next) * 10]
		ifFalse: [ 
			direction normalized * ((self repelStrengthTo: aMorph) + (aMorph repelStrengthTo: self))]
]

{ #category : #'colors and color policies' }
SBBlock >> foregroundColor [

	^ self
		valueOfProperty: #foregroundColorCache
		ifAbsentPut: [self colorPolicy foregroundColorForBlock: self]
]

{ #category : #decorators }
SBBlock >> forwardAlarm: aSelector to: anObject [

	anObject perform: aSelector
]

{ #category : #drawing }
SBBlock >> frameSize [

	^ self colorPolicy ifNotNil: [:c | c selectionBorderWidth] ifNil: [0]
]

{ #category : #accessing }
SBBlock >> grammarHandler [

	^ nil
]

{ #category : #'as yet unclassified' }
SBBlock >> group [ 
	
	^ self withDecorator: SBForceMoveDecorator do: [:decorator | decorator group] ifAbsent: [nil]
]

{ #category : #'event handling' }
SBBlock >> handlesMouseDown: anEvent [

	^ anEvent redButtonPressed or: [SBPreferences rightClickContextMenu and: [anEvent yellowButtonPressed]]
]

{ #category : #'testing hierarchy' }
SBBlock >> hasChildSandblocks [

	self childSandblocksDo: [:b | ^ true].
	^ false
]

{ #category : #'actions tests' }
SBBlock >> hasCommandPalette [

	^ SBPalette allSubclasses anySatisfy: [:palette | (self satisfies: palette context) and: [palette matchesBlock: self]]
]

{ #category : #'actions tests' }
SBBlock >> hasCurrentTextMorph [

	^ self currentTextMorph notNil
]

{ #category : #decorators }
SBBlock >> hasDecorator: aClass [

	^ decorators anySatisfy: [:d | d isKindOf: aClass]
]

{ #category : #'as yet unclassified' }
SBBlock >> hasGroup [ 
	
	^ self group notNil
]

{ #category : #testing }
SBBlock >> hasInput [

	^ self isSelected and: [self sandblockEditor mode = #input]
]

{ #category : #'actions tests' }
SBBlock >> hasMultiSelection [

	^ self sandblockEditor cursor cursorPosition isKindOf: SBCursorMultiSelect
]

{ #category : #'actions tests' }
SBBlock >> hasSuggestions [

	| editor |
	editor := self sandblockEditor.
	^ editor notNil and: [editor suggestionMenu isInWorld and: [editor suggestionMenu reference = self]]
]

{ #category : #testing }
SBBlock >> hasUnsavedChanges [

	^ self sandblockEditor ifNotNil: [:e | e hasUnsavedChanges: self] ifNil: [false]
]

{ #category : #connections }
SBBlock >> incomingConnectionsDo: aBlock [

	self allConnectionsDo: [:m | m to = self ifTrue: [aBlock value: m]]
]

{ #category : #initialization }
SBBlock >> initialize [

	super initialize.
	
	decorators := OrderedCollection new.
	
	color := Color transparent.
	bounds := 0 @ 0 extent: 0 @ 0.
	self
		cellPositioning: #topLeft;
		layoutInset: 0;
		cellGap: 1 sbScaled
]

{ #category : #actions }
SBBlock >> inputContainedUnknown [
	<action>
	<inputAction>

	self cursorPositionsDo: [:pos |
		pos isJumpPoint ifTrue: [
			self sandblockEditor cursorPosition: pos.
			^ true]].
	^ false
]

{ #category : #actions }
SBBlock >> inputNextUnknown [
	<action>
	<inputAction>

	((self sandblockEditor cursor selectedBlock = self or: [self sandblockEditor cursor selectedBlock hasOwner: self])
		ifTrue: [self sandblockEditor cursor nextCursorThat: [:pos | pos isJumpPoint]]
		ifFalse: [self cursorPositionInSelfOrAfterThat: [:pos | pos isJumpPoint]]) ifNotNil: [:pos | self sandblockEditor cursorPosition: pos]
]

{ #category : #actions }
SBBlock >> inputPreviousUnknown [
	<action>
	<inputAction>

	((self sandblockEditor cursor selectedBlock = self or: [self sandblockEditor cursor selectedBlock hasOwner: self])
		ifTrue: [self sandblockEditor cursor previousCursorThat: [:pos | pos isJumpPoint]]
		ifFalse: [self cursorPositionBeforeThat: [:pos | pos isJumpPoint]]) ifNotNil: [:pos | self sandblockEditor cursorPosition: pos]
]

{ #category : #'insert/delete' }
SBBlock >> insertCommandRequest: aMorph near: aBlock before: aBoolean [
	" the user tries to add a block to us, do we want to do something now? "

	self fixedNumberOfChildren ifTrue: [^ nil].
	
	^ SBRelInsertCommand new
		near: aBlock before: aBoolean in: self morph: aMorph;
		yourself
]

{ #category : #'action helpers' }
SBBlock >> insertElement: aBeforeBoolean [

	| cmd |
	cmd := (self parentSandblock
		insertEmptyCommandRequestNear: self
		before: aBeforeBoolean) ifNil: [^ self].
	
	self sandblockEditor do: cmd.
	
	cmd shouldMergeWithNext ifTrue: [self sandblockEditor selection inputContainedUnknown].
	
	^ self sandblockEditor selection
]

{ #category : #actions }
SBBlock >> insertElementAfter [
	<action>
	<inputAction>
	<actionValidIf: #canInsertAfter>

	^ self insertElement: false
]

{ #category : #actions }
SBBlock >> insertElementBefore [
	<action>
	<inputAction>
	<actionValidIf: #canInsertBefore>

	^ self insertElement: true
]

{ #category : #'as yet unclassified' }
SBBlock >> insertEmptyCommandRequestNear: aBlock before: aBoolean [

	| child |
	child := self newEmptyChildNear: aBlock before: aBoolean.
	child ifNil: [^ nil].
	
	^ (self
		insertCommandRequest: child
		near: aBlock
		before: aBoolean) ifNotNil: [:cmd |
		cmd
			shouldMergeWithNext: true;
			yourself]
]

{ #category : #'insert positions' }
SBBlock >> insertPositions [

	^ Array streamContents: [:stream | self cursorPositionsDo: [:pos | pos isInsert ifTrue: [stream nextPut: pos]]]
]

{ #category : #actions }
SBBlock >> insertStatementAbove [
	<action>
	<actionValidIf: #insertStatementHasCandidate>

	self insertStatementAboveOrBelow: true
]

{ #category : #'action helpers' }
SBBlock >> insertStatementAboveOrBelow: anAboveBoolean [

	| candidate |
	self grammarHandler ifNotNil: [:g |
		^ g
			block: self;
			insertStatementAboveOrBelow: anAboveBoolean].
	
	" default behavior is to find the first parent that can take multiple children "
	candidate := self.
	[candidate parentSandblock fixedNumberOfChildren and: [candidate isArtefact not]] whileTrue: [candidate := candidate parentSandblock].
	(candidate isArtefact not and: [candidate parentSandblock ~= candidate sandblockEditor]) ifTrue: [candidate insertElement: anAboveBoolean]
]

{ #category : #actions }
SBBlock >> insertStatementBelow [
	<action>
	<actionValidIf: #insertStatementHasCandidate>

	self insertStatementAboveOrBelow: false
]

{ #category : #'action helpers' }
SBBlock >> insertStatementFindCandidate [

	| candidate |
	" default behavior is to find the first parent that can take multiple children "
	candidate := self.
	[candidate parentSandblock fixedNumberOfChildren and: [candidate isArtefact not]] whileTrue: [candidate := candidate parentSandblock].
	candidate isArtefact ifFalse: [^ candidate].
	^ nil
]

{ #category : #'as yet unclassified' }
SBBlock >> insertStatementHasCandidate [

	^ self insertStatementFindCandidate
		ifNotNil: [:c | (c parentSandblock insertEmptyCommandRequestNear: c before: false) notNil]
		ifNil: [false]
]

{ #category : #initialization }
SBBlock >> intoWorld: aWorld [

	super intoWorld: aWorld.
	self triggerEvent: #insert.	
	self updateSteppingDecorators
]

{ #category : #'dropping/grabbing' }
SBBlock >> invokeMetaMenu: anEvent [
	"self pickUp: anEvent"
	" We hijack this event because it's the only way to cleanly access ctrl+click "

	anEvent
		transformBy: (self transformFrom: nil);
		instVarNamed: #buttons
			put: ((anEvent buttons bitClear: MouseEvent anyButton) bitOr: MouseEvent redButton);
		instVarNamed: #whichButton
			put: ((anEvent whichButton bitClear: MouseEvent anyButton) bitOr: MouseEvent redButton).
	" for some reason, this event gets modified buttons assignments (yellow instead of red) "
	
	anEvent sentTo: self
]

{ #category : #testing }
SBBlock >> isArtefact [
	" we define an artefact in this context as a node that is in some way persisting information of its children such as a method or a class would "

	^ false
]

{ #category : #layout }
SBBlock >> isAttractedTo: aMorph [
	
	^ aMorph object class = self object class
]

{ #category : #testing }
SBBlock >> isBlockBody [

	^ false
]

{ #category : #testing }
SBBlock >> isClassContainer [

	^ false
]

{ #category : #testing }
SBBlock >> isDeclaration [

	^ false
]

{ #category : #'as yet unclassified' }
SBBlock >> isDragging [ 
	
	^ self withDecorator: SBMoveDecorator do: [:decorator | decorator isDragging] ifAbsent: [false]
]

{ #category : #testing }
SBBlock >> isEditor [

	^ false
]

{ #category : #testing }
SBBlock >> isExpression [

	^ false
]

{ #category : #'testing hierarchy' }
SBBlock >> isFirstChild [

	self parentSandblock childSandblocksDo: [:c | ^ c = self]
]

{ #category : #'testing hierarchy' }
SBBlock >> isInEditor [

	| editor |
	editor := self sandblockEditor.
	^ editor notNil and: [editor isSelection not or: [editor parentSandblock ifNotNil: #isInEditor ifNil: [false]]]
]

{ #category : #'Sandblocks-TreeSitter' }
SBBlock >> isInlineBlock [

	^ false
]

{ #category : #'testing hierarchy' }
SBBlock >> isLastChild [

	^ self parentSandblock childSandblocks last = self
]

{ #category : #'testing hierarchy' }
SBBlock >> isLastDeepChild [

	^ self = self lastDeepChild
]

{ #category : #testing }
SBBlock >> isLiteralBlock [

	^ false
]

{ #category : #testing }
SBBlock >> isMethod [

	^ false
]

{ #category : #testing }
SBBlock >> isMethodBody [

	^ false
]

{ #category : #testing }
SBBlock >> isMultiSelected [

	^ self sandblockEditor ifNil: [false] ifNotNil: [:editor | editor multiSelection includes: self]
]

{ #category : #testing }
SBBlock >> isNumberBlock [

	^ false
]

{ #category : #testing }
SBBlock >> isOneStatementPerArtefact [

	^ false
]

{ #category : #testing }
SBBlock >> isSandblock [

	^ true
]

{ #category : #testing }
SBBlock >> isScope [

	^ false
]

{ #category : #testing }
SBBlock >> isSelectable [

	^ true
]

{ #category : #testing }
SBBlock >> isSelected [

	^ self sandblockEditor ifNil: [false] ifNotNil: [:editor | editor selection = self]
]

{ #category : #testing }
SBBlock >> isSelection [

	^ false
]

{ #category : #testing }
SBBlock >> isStatement [

	^ self owner isBlockBody
]

{ #category : #testing }
SBBlock >> isTopLevel [

	^ false
]

{ #category : #testing }
SBBlock >> isUnknown [

	^ false
]

{ #category : #'action helpers' }
SBBlock >> isValidAction: aPragmaOrMethod [

	| mode validInvocation validMode allPragmas method |
	allPragmas := #(#action #inputAction #multiSelectAction).
	
	aPragmaOrMethod isCompiledMethod
		ifTrue: [method := aPragmaOrMethod]
		ifFalse: [method := aPragmaOrMethod method].
	
	mode := self sandblockEditor mode.
	validMode := (mode = #input ifTrue: [allPragmas] ifFalse: [#(#action #multiSelectAction)]) anySatisfy: [:s | (method pragmaAt: s) notNil].
	validInvocation := (method pragmaAt: #actionValidIf:) ifNotNil: [:p |
		p arguments first precedence = 3 ifTrue: [method methodClass theNonMetaClass perform: p arguments first with: self] ifFalse: [self perform: p arguments first]] ifNil: [true].
	
	^ validMode and: [validInvocation]
]

{ #category : #testing }
SBBlock >> isWatch [

	^ false
]

{ #category : #'as yet unclassified' }
SBBlock >> isWaypoint [

	^ false
]

{ #category : #'event handling' }
SBBlock >> keyStroke: anEvent [

	self currentTextMorph ifNotNil: [
		self sandblockEditor currentInputCommand textMorph keyStroke: anEvent.
		self queueUpdateSuggestionsFocused: true.
		self batchedChangeStep]
]

{ #category : #hierarchy }
SBBlock >> lastDeepChild [

	| current |
	current := self.
	[current childSandblocks isEmpty] whileFalse: [current := current childSandblocks last].
	^ current
]

{ #category : #'insert positions' }
SBBlock >> lastInsertPosition [

	| last |
	last := nil.
	self cursorPositionsDo: [:pos | pos isInsert ifTrue: [last := pos]].
	^ last
]

{ #category : #layout }
SBBlock >> layoutCommands [

	^ SBAlgebraCommand morph data: self
]

{ #category : #layout }
SBBlock >> layoutInset [

	| space inset |
	space := self spaceForSymbols.
	inset := (self colorPolicy layoutInsetFor: self) + super layoutInset.
	^ (space first > 0 or: [space second > 0])
		ifTrue: [
			inset isPoint
				ifTrue: [
					SBEdgeInsets
						left: space first + inset x
						right: inset x + space second
						top: inset y
						bottom: inset y]
				ifFalse: [SBEdgeInsets left: space first + inset right: inset + space second top: inset bottom: inset]]
		ifFalse: [inset]
]

{ #category : #hierarchy }
SBBlock >> leftMostBlock [

	^ self childSandblocks ifEmpty: [self] ifNotEmpty: [:c | c first leftMostBlock]
]

{ #category : #actions }
SBBlock >> leftRotate [
	<action>
	<actionValidIf: #hasChildSandblocks>

	(self hasChildSandblocks not or: [self parentSandblock isNil]) ifTrue: [^ self].
	(self isFirstChild or: [self isLastChild]) ifFalse: [^ self].
	
	self sandblockEditor do: (SBSubtreeRotateCommand new
		target: self;
		yourself)
]

{ #category : #'colors and color policies' }
SBBlock >> localColorPolicy: aPolicy [

	self
		setProperty: #localColorPolicy toValue: aPolicy;
		clearCache;
		changed
]

{ #category : #hierarchy }
SBBlock >> localNestingDepth [

	^ 1 + (self parentSandblock ifNotNil: [:p | p localNestingDepth] ifNil: [0])
]

{ #category : #'action helpers' }
SBBlock >> lookupAction: aSymbol [

	| symbolWithArg |
	symbolWithArg := (aSymbol, ':') asSymbol.
	self actionProviders do: [:provider |
		{aSymbol. symbolWithArg} do: [:sym |
			((provider class lookupSelector: sym)
				ifNotNil: [:m | self isValidAction: m]
				ifNil: [false]) ifTrue: [^ provider]]].
	^ nil
]

{ #category : #'action helpers' }
SBBlock >> lookupGlobalAction: aSymbol [

	^ (self class lookupSelector: aSymbol) ifNotNil: [:m | ((m pragmaAt: #globalAction) notNil and: [(m pragmaAt: #actionValidIf:) ifNotNil: [:p | self perform: p arguments first] ifNil: [true]]) ifTrue: [m] ifFalse: [nil]]
]

{ #category : #suggestions }
SBBlock >> maxSuggestions [

	^ 50
]

{ #category : #'as yet unclassified' }
SBBlock >> maximumNonOverlappingForce [

	^ 10
]

{ #category : #suggestions }
SBBlock >> maybeUpdateSuggestions [

	| menu |
	self sandblockEditor ifNil: [^ self].
	menu := self sandblockEditor suggestionMenu.
	menu updateQueued ifTrue: [self updateSuggestions]
]

{ #category : #layout }
SBBlock >> minExtent [
	"Layout specific. Return the minimum size the receiver can be represented in.
	Implementation note: When this message is sent from an owner trying to lay out its children it will traverse down the morph tree and recompute the minimal arrangement of the morphs based on which the minimal extent is returned. When a morph with some layout strategy is encountered, the morph will ask its strategy to compute the new arrangement. However, since the final size given to the receiver is unknown at the point of the query, the assumption is made that the current bounds of the receiver are the base on which the layout should be computed. This scheme prevents strange layout changes when for instance, a table is contained in another table. Unless the inner table has been resized manually (which means its bounds are already enlarged) the arrangement of the inner table will not change here. Thus the entire layout computation is basically an iterative process which may have different results depending on the incremental changes applied."

	| layout minExtent extra hFit vFit |
	hFit := self hResizing.
	vFit := self vResizing.

	"An exception -- a receiver with #shrinkWrap constraints but no children is being treated #rigid (the equivalent to a #spaceFill receiver in a non-layouting owner)"
	self hasSubmorphs 
		ifFalse: 
			[hFit == #shrinkWrap ifTrue: [hFit := #rigid].
			vFit == #shrinkWrap ifTrue: [vFit := #rigid]].
	layout := self layoutPolicy.
	layout isNil 
		ifTrue: [minExtent := 0@0]
		ifFalse: [minExtent := layout minExtentOf: self in: self layoutBounds].

	hFit == #rigid 
		ifTrue: [minExtent := self fullBounds extent x @ minExtent y]
		ifFalse: 
			[extra := self bounds width - self layoutBounds width.
			minExtent := (minExtent x + extra) @ minExtent y].
	vFit == #rigid 
		ifTrue: [minExtent := minExtent x @ self fullBounds extent y]
		ifFalse: 
			[extra := self bounds height - self layoutBounds height.
			minExtent := minExtent x @ (minExtent y + extra)].

	^ minExtent max: self minWidth @ self minHeight
]

{ #category : #accessing }
SBBlock >> morphicLayerNumber [

	^ 100
]

{ #category : #accessing }
SBBlock >> mouseCursorAt: anEvent [

	| cursor priority |
	" return your preferred cursor here "
	cursor := nil.
	priority := -1.
	self decorators do: [:decorator |
		(decorator mouseCursorAt: anEvent) ifNotNil: [:pair |
			pair second > priority ifTrue: [
				cursor := pair first.
				priority := pair second]]].
	^ cursor
]

{ #category : #'event handling' }
SBBlock >> mouseDown: anEvent [

	self eventHandler ifNotNil: [self eventHandler mouseDown: anEvent fromMorph: self].
	
	anEvent hand
		waitForClicksOrDrag: self
		event: anEvent
		selectors: #(#click: #doubleClick: #doubleClickTimeout: #startDrag:)
		threshold: 30
]

{ #category : #actions }
SBBlock >> moveCursorToEnd [
	<inputAction>
	<actionValidIf: #hasCurrentTextMorph>

	self currentTextMorph ifNotNil: [:t | t moveCursorTo: 9e8]
]

{ #category : #actions }
SBBlock >> moveCursorToStart [
	<inputAction>
	<actionValidIf: #hasCurrentTextMorph>

	self currentTextMorph moveCursorTo: 1
]

{ #category : #actions }
SBBlock >> multiSelectChildren [
	<action>
	<actionValidIf: #hasChildSandblocks>

	self sandblockEditor multiSelection: self childSandblocks
]

{ #category : #'as yet unclassified' }
SBBlock >> newEmptyChildNear: aBlock before: aBoolean [

	^ self grammarHandler ifNotNil: [:g | g newNullBlock] ifNil: [nil]
]

{ #category : #'ast helpers' }
SBBlock >> newNullBlock [

	^ (self parentSandblock ifNil: [self])
		newEmptyChildNear: nil
		before: true
]

{ #category : #hierarchy }
SBBlock >> nextDeletableBlock [

	^ ((self parentSandblock ifNil: [^ nil]) deleteCommandFor: self)
		ifNotNil: [self]
		ifNil: [self parentSandblock nextDeletableBlock]
]

{ #category : #hierarchy }
SBBlock >> nextVerticalNear: aNumber [

	^ self
		nextVerticalNear: aNumber
		calcDistance: [:candidate | candidate top - self bottom]
		validBlock: [:candidate | candidate top >= self bottom]
]

{ #category : #hierarchy }
SBBlock >> nextVerticalNear: aNumber calcDistance: aDistBlock validBlock: aValidBlock [

	| allCandidates candidates candidatesBestDistance tolerance artefact |
	artefact := self containingFloat.
	tolerance := 10.
	
	allCandidates := Array streamContents: [:stream | artefact allMorphsDo: [:candidate | ((candidate isTextMorph or: [candidate isSandblock and: [candidate hasChildSandblocks not]]) and: [aValidBlock value: candidate]) ifTrue: [stream nextPut: candidate]]].
	
	candidates := OrderedCollection new.
	candidatesBestDistance := 900000000.
	allCandidates do: [:candidate | | distance |
		distance := aDistBlock value: candidate.
		distance < candidatesBestDistance
			ifTrue: [
				(candidatesBestDistance between: distance and: distance + tolerance)
					ifTrue: [candidates add: candidate]
					ifFalse: [candidates := OrderedCollection with: candidate].
				candidatesBestDistance := distance]
			ifFalse: [(distance between: candidatesBestDistance and: candidatesBestDistance + tolerance) ifTrue: [candidates add: candidate]]].
	
	^ (candidates detectMin: [:candidate | (candidate left - artefact left to: candidate right - artefact left) distanceTo: aNumber]) ifNotNil: #containingSandblock
]

{ #category : #callbacks }
SBBlock >> noteNewOwner: aMorph [

	super noteNewOwner: aMorph.
	self decorators copy do: [:decorator | decorator noteNewOwner: aMorph].
	self clearCache
]

{ #category : #'object interface' }
SBBlock >> object [

	"Should be self subclassResponsibility but often causes non-recoverable errors with drag and drop"
	^ self
]

{ #category : #'object interface' }
SBBlock >> objectInterface [

	^ self parentSandblock objectInterfaceForChild: self
]

{ #category : #'object interface' }
SBBlock >> objectInterfaceForChild: aBlock [

	^ self objectInterfaceNear: aBlock at: #replace
]

{ #category : #'object interface' }
SBBlock >> objectInterfaceForDrop: aBlock near: anotherBlock at: aSymbol [

	^ self objectInterfaceNear: anotherBlock at: aSymbol
]

{ #category : #'object interface' }
SBBlock >> objectInterfaceForInsert: aCommand [

	| adjacent at |
	at := #before.
	adjacent := self childSandblocks at: aCommand insertIndex ifAbsent: [
		at := #after.
		self hasChildSandblocks ifTrue: [self childSandblocks last] ifFalse: [nil]].
	^ self objectInterfaceNear: adjacent at: at
]

{ #category : #'object interface' }
SBBlock >> objectInterfaceNear: aBlock at: aSymbol [

	^ SBInterfaces never
]

{ #category : #hierarchy }
SBBlock >> open [
	" tries to find the current SBEditor and open our block in it "

	SBExecutionEnvironment value sandblockEditor
		ifNotNil: [:editor | editor openMorphInView: self]
		ifNil: [self error: 'No editor found in execution context']
]

{ #category : #actions }
SBBlock >> openLocalPalette [
	<action>
	<actionValidIf: #hasCommandPalette>

	| palettes |
	self sandblockEditor isSingleArtefactView ifTrue: [
		^ self sandblockEditor togglePalette].

	palettes := SBPalette allSubclasses select: [:palette | (self satisfies: palette context) and: [palette matchesBlock: self]].
	palettes ifNotEmpty: [ | container |
		container := SBPaletteContainer new.
		palettes do: [:class | class buildOn: container].
		self sandblockEditor openMorphInView: container]
]

{ #category : #initialization }
SBBlock >> outOfWorld: aWorld [

	super outOfWorld: aWorld.
	
	self removeSuggestionMenu.
	self triggerEvent: #outOfWorld
]

{ #category : #'as yet unclassified' }
SBBlock >> outerArtefact [

	| a |
	a := self containingArtefact.
	^ a = self ifTrue: [self parentSandblock ifNotNil: #containingArtefact] ifFalse: [a]
]

{ #category : #'as yet unclassified' }
SBBlock >> outerMostArtefact [

	| a |
	a := self containingArtefact.
	a ownerChain do: [:morph | (morph isSandblock and: [morph isArtefact]) ifTrue: [a := morph]].
	^ a
]

{ #category : #connections }
SBBlock >> outgoingConnectionsDo: aBlock [

	self allConnectionsDo: [:m | m from = self ifTrue: [aBlock value: m]]
]

{ #category : #hierarchy }
SBBlock >> ownerWithBackgroundColor [

	^ self drawnColor isTransparent not
		ifTrue: [self]
		ifFalse: [self owner ifNotNil: [:o | o ownerWithBackgroundColor]]
]

{ #category : #hierarchy }
SBBlock >> ownerWithForegroundColor [

	^ nil
]

{ #category : #accessing }
SBBlock >> palettes [

	" return SBPalette subclasses you'd like to have displayed here "
	^ #()
]

{ #category : #hierarchy }
SBBlock >> parentAdjacentBlock: aNumber [

	^ (self adjacentBlock: aNumber)
		ifNil: [self parentSandblock ifNotNil: [:p | p parentAdjacentBlock: aNumber]]
]

{ #category : #'testing hierarchy' }
SBBlock >> parentHasDynamicNumberOfChildren [

	^ self parentSandblock fixedNumberOfChildren not
]

{ #category : #actions }
SBBlock >> pasteAfter [
	<action>

	self pasteBeforeOrAfter: false
]

{ #category : #actions }
SBBlock >> pasteBefore [
	<action>

	self pasteBeforeOrAfter: true
]

{ #category : #'action helpers' }
SBBlock >> pasteBeforeOrAfter: aBeforeBoolean [

	self sandblockEditor
		copyBufferForContext: (self parentSandblock
			objectInterfaceNear: self
			at: (aBeforeBoolean ifTrue: [#before] ifFalse: [#after]))
		reversed: true
		do: [:repr :index :isLast | (self parentSandblock insertCommandRequest: repr near: self before: aBeforeBoolean) ifNotNil: [:cmd | self sandblockEditor do: (cmd shouldMergeWithNext: isLast not)]]
		ifWrappingDo: [:block | self wrapSelectionWith: block unpackSelection veryDeepCopy]
]

{ #category : #actions }
SBBlock >> pasteReplace [
	<action>

	| position editor |
	editor := self sandblockEditor.
	position := editor cursor cursorPosition.
	editor
		copyBufferForContext: (position isInsert
			ifTrue: [position container objectInterfaceForInsert: position command]
			ifFalse: [self objectInterface])
		reversed: (position isInsert and: [position adjacent notNil])
		do: [:block :index :isLast |
			position isInsert
				ifTrue: [
					editor do: (position command copy
						morph: block;
						shouldMergeWithNext: isLast not;
						selectAfter: #block)]
				ifFalse: [
					index = 1 ifTrue: [
						editor do: (SBReplaceCommand new
							selectAfter: #block;
							target: self;
							replacer: block)]]]
		ifWrappingDo: [:block | self wrapSelectionWith: block]
]

{ #category : #'action helpers' }
SBBlock >> performAction: aSymbol [

	(self lookupAction: aSymbol) ifNotNil: [:obj |
		(obj ~= self and: [obj respondsTo: #block:]) ifTrue: [obj block: self].
		(obj respondsTo: aSymbol)
			ifTrue: [obj perform: aSymbol]
			ifFalse: [obj perform: (aSymbol, ':') asSymbol with: self].
		^ true].
	^ false
	"self actionProviders do: [:obj |
		(obj class lookupSelector: aSymbol) ifNotNil: [:m |
			(self isValidAction: m) ifTrue: [
				obj ~= self ifTrue: [obj block: self].
				^ obj perform: aSymbol]]]"
]

{ #category : #'dropping/grabbing' }
SBBlock >> pickUp: anEvent [

	| editor s |
	self canDrag ifFalse: [^ self].
	
	editor := self sandblockEditor.
	s := SBDragContainer new
		homeArtefact: self containingArtefact;
		methodClass: (self containingArtefact ifNotNil: #relatedClass);
		colorPolicy: self colorPolicy;
		sourceBlock: self;
		onAbortUndoIn: editor;
		yourself.
	
	self containingBlock ifNotNil: [:b | (b sandblockBlockColorIfAbsent: [nil]) ifNotNil: [:c | s color: c]].
	
	s addMorphBack: self dragTarget.
	anEvent hand grabMorph: s.
	editor select: nil.
	
	SBToggledCode comment: '' active: 0 do: {
		[
			(anEvent shiftPressed not and: [self copyOnDrag not]) ifTrue: [
				(self parentSandblock deleteCommandFor: self) ifNotNil: [:cmd |
					editor do: (cmd
						shouldMergeWithNext: true;
						selectAfter: #none;
						yourself)]]]}
]

{ #category : #actions }
SBBlock >> placeMark [
	<action>

	(self hasDecorator: SBMarkedDecorator)
		ifTrue: [self detachDecorators: SBMarkedDecorator]
		ifFalse: [
			self sandblockEditor waitForLetterDo: [:letter |
				self attachDecorator: (SBMarkedDecorator new letter: letter)]]
]

{ #category : #caching }
SBBlock >> postDuplicate [

	self allBlocksDo: [:morph | morph postDuplicateSelf].
	self detachDecorators: SBMultiSelectionDecorator.
	self clearCache
]

{ #category : #caching }
SBBlock >> postDuplicateSelf [
	" this block has been duplicated, adjust any identifiers if need be "

	
]

{ #category : #accessing }
SBBlock >> precedence [
	" some edit systems may support automatic reshuffling based on operator precedence. override this selector to return the specific precedence "

	^ 0
]

{ #category : #testing }
SBBlock >> preferInsertCursor [
	"communicate that you would prefer to receive an insert cursor whenever clicked, not a select cursor"

	^ false
]

{ #category : #'colors and color policies' }
SBBlock >> preferredColor [

	^ nil
]

{ #category : #'colors and color policies' }
SBBlock >> preferredColorIn: aColorPolicy [

	^ aColorPolicy default
]

{ #category : #'colors and color policies' }
SBBlock >> prefersNoBorder [

	^ false
]

{ #category : #actions }
SBBlock >> prependElement [
	<action>

	| cmd |
	cmd := (self
		insertEmptyCommandRequestNear: (self childSandblocks ifNotEmpty: #first ifEmpty: [nil])
		before: true) ifNil: [^ self].
	
	self sandblockEditor do: cmd.
	
	cmd shouldMergeWithNext ifTrue: [
		self sandblockEditor
			startInput: self sandblockEditor selection
			at: 0
			replacingContents: false]
]

{ #category : #testing }
SBBlock >> preventOcclusion [

	^ true
]

{ #category : #hierarchy }
SBBlock >> previousVerticalNear: aNumber [

	^ self
		nextVerticalNear: aNumber
		calcDistance: [:candidate | self top - candidate bottom]
		validBlock: [:candidate | self top >= candidate bottom]
]

{ #category : #'as yet unclassified' }
SBBlock >> printIdentityStringOn: aStream [

	aStream
		nextPutAll: self className;
		print: self identityHash
]

{ #category : #saving }
SBBlock >> printSaveStringPreambleOn: aStream [

	self printIdentityStringOn: aStream.
	aStream nextPutAll: ' := '
]

{ #category : #initialization }
SBBlock >> privateOwner: aMorph [

	super privateOwner: aMorph.
	aMorph ifNil: [self triggerEvent: #delete]
]

{ #category : #actions }
SBBlock >> promptAction [
	<multiSelectAction>
	<inputAction>

	| options index |
	options := self validActions.
	index := UIManager default chooseFrom: (options collect: [:option |
		option method selector, (' ', (SBEditor shortcutStringForAction: option selector))]).
	index > 0 ifTrue: [self performAction: (options at: index) method selector]
]

{ #category : #actions }
SBBlock >> promptChangeCompile [
	<action>

	self sandblockEditor promptChangeCompile
]

{ #category : #'ast helpers' }
SBBlock >> proposeCodeActions: aCollection for: aBlock [

	| index |
	index := UIManager default chooseFrom: (aCollection collect: #label).
	index > 0 ifTrue: [(aCollection at: index) do]
]

{ #category : #testing }
SBBlock >> providesExecutionEnvironment [

	^ false
]

{ #category : #suggestions }
SBBlock >> queueUpdateSuggestionsFocused: aBoolean [

	| editor |
	editor := self sandblockEditor.
	editor ifNil: [^ self].
	
	editor suggestionMenu
		updateQueued: true;
		focusOnOpen: aBoolean.
	self addAlarm: #maybeUpdateSuggestions after: 0
]

{ #category : #actions }
SBBlock >> refocus [
	<multiSelectAction>

	self ensureVisible
]

{ #category : #'artefact protocol' }
SBBlock >> relatedClass [

	^ self object class
]

{ #category : #actions }
SBBlock >> reloadArtefact [
	<action>

	
	self isArtefact ifFalse: [self containingArtefact ifNotNil: #reloadArtefact]
]

{ #category : #'colors and color policies' }
SBBlock >> removeLocalColorPolicy [

	self
		removeProperty: #localColorPolicy;
		clearCache;
		changed
]

{ #category : #suggestions }
SBBlock >> removeSuggestionMenu [

	self hasSuggestions ifTrue: [self sandblockEditor suggestionMenu delete]
]

{ #category : #'as yet unclassified' }
SBBlock >> repelStrengthTo: aMorph [

	| distance |
	distance := (self bounds vectorToRectangle: aMorph bounds) r.
	^ distance > self class maxRepelDistance ifTrue: [0] ifFalse: [
		(distance closeTo: 0)
			ifTrue: [self class maximumNonOverlappingForce + ((self bounds intersect: aMorph bounds) area sqrt / 10)]
			ifFalse: [self class defaultRepelStrength / distance / distance min: self class maximumNonOverlappingForce]]
]

{ #category : #hierarchy }
SBBlock >> rightMostBlock [

	^ self childSandblocks ifEmpty: [self] ifNotEmpty: [:c | c last rightMostBlock]
]

{ #category : #'colors and color policies' }
SBBlock >> sandblockBlockColorIfAbsent: aBlock [

	^ self valueOfProperty: #sandblockBlockColor ifAbsent: aBlock
]

{ #category : #'colors and color policies' }
SBBlock >> sandblockBlockColorIfAbsentPut: aBlock [

	^ self sandblockBlockColorIfAbsent: [ | newColor |
		newColor := aBlock value.
		self setProperty: #sandblockBlockColor toValue: newColor. newColor]
]

{ #category : #'colors and color policies' }
SBBlock >> sandblockForegroundColor [

	^ self foregroundColor
]

{ #category : #'artefact protocol' }
SBBlock >> save [

	(self saveTryFixing: false quick: false) ifFalse: [self error: 'failed to save block']
]

{ #category : #saving }
SBBlock >> saveString [

	^ String streamContents: [:stream |
		self printSaveStringPreambleOn: stream.
		stream
			nextPutAll: self className;
			nextPutAll: ' new position: ';
			nextPutAll: self position asString.
		self childSandblocks do: [:each |
			stream
				nextPutAll: ';';
				cr;
				nextPutAll: 'addMorphBack: (';
				nextPutAll: each saveString;
				nextPutAll: ')']]
]

{ #category : #'artefact protocol' }
SBBlock >> saveTryFixing: aFixBoolean quick: aQuickBoolean [
	" only needed if this block is an artefact "

	^ self subclassResponsibility
]

{ #category : #'ast helpers' }
SBBlock >> scopesDo: aBlock [

	self isScope ifTrue: [aBlock value: self].
	self parentSandblock ifNotNil: [:p | p scopesDo: aBlock]
]

{ #category : #actions }
SBBlock >> screenshot [
	<action>

	| name path |
	
	name := self name, '.png'.
	path := FileDirectory default fullName, '/', name.
	self imageForm writePNGfileNamed: name.
	Smalltalk
		at: #ExternalWebBrowser
		ifPresent: [:e | e openOnUrl: 'file://', path]
		ifAbsent: [self inform: 'Saved under ', path]
]

{ #category : #actions }
SBBlock >> select [
	<action>

	self sandblockEditor select: self
]

{ #category : #actions }
SBBlock >> selectAdjacent [
	<action>

	self sandblockEditor multiSelection: self parentSandblock childSandblocks
]

{ #category : #actions }
SBBlock >> selectAdjacentAfter [
	<action>

	self sandblockEditor multiSelection: (self parentSandblock childSandblocks allButFirst: self childIndex - 1)
]

{ #category : #actions }
SBBlock >> selectAdjacentBefore [
	<action>

	self sandblockEditor multiSelection: (self parentSandblock childSandblocks first: self childIndex)
]

{ #category : #actions }
SBBlock >> selectArtefact [
	<multiSelectAction>
	<inputAction>

	(self containingArtefact = self
		ifTrue: [self parentSandblock containingArtefact]
		ifFalse: [self containingArtefact])
		ifNotNil: #select
		ifNil: [self containingFloat ifNotNil: #select]
]

{ #category : #actions }
SBBlock >> selectBottomToplevel [
	<multiSelectAction>
	
	self selectToplevelTowards: #bottom
]

{ #category : #actions }
SBBlock >> selectLast [
	<multiSelectAction>
	<inputAction>

	self containingFloat lastDeepChild
		select;
		startInputAtEnd
]

{ #category : #'as yet unclassified' }
SBBlock >> selectLastInsertPosition [

	| last |
	last := nil.
	self cursorPositionsDo: [:pos | last := pos].
	last
		ifNotNil: [self sandblockEditor cursor cursorPosition: last explicitMove: true axis: #none]
		ifNil: [self select]
]

{ #category : #actions }
SBBlock >> selectLeftToplevel [
	<multiSelectAction>
	
	self selectToplevelTowards: #left
]

{ #category : #actions }
SBBlock >> selectRightMostBlock [
	<multiSelectAction>
	<inputAction>

	self containingStatement ifNil: [self rightMostBlock select] ifNotNil: [:statement |
		statement rightMostBlock
			select;
			startInputAtEnd]
]

{ #category : #actions }
SBBlock >> selectRightToplevel [
	<multiSelectAction>
	
	self selectToplevelTowards: #right
]

{ #category : #actions }
SBBlock >> selectTopToplevel [
	<multiSelectAction>
	
	self selectToplevelTowards: #top
]

{ #category : #'action helpers' }
SBBlock >> selectToplevelTowards: aSideSymbol [

	| opposite |
	self sandblockEditor = self containingToplevel ifTrue: [^ self].
	
	opposite := aSideSymbol caseOf: {
		[#left] -> [#right].
		[#right] -> [#left].
		[#top] -> [#bottom].
		[#bottom] -> [#top]}.
	(self containingToplevel
		closestAdjacentFrom: (aSideSymbol, 'Center') asSymbol
		to: (opposite, 'Center') asSymbol) select
]

{ #category : #callbacks }
SBBlock >> selectedTextMorph: aMorph [

	
]

{ #category : #printing }
SBBlock >> selectionLabel [

	^ self printString
]

{ #category : #'actions tests' }
SBBlock >> shouldAutocomplete [

	^ self hasSuggestions and: [self sandblockEditor suggestionMenu activeSuggestion wouldChange: self]
]

{ #category : #suggestions }
SBBlock >> shouldSuggest [

	^ self suggestAlways or: [self activeTextMorph contents size >= 2]
]

{ #category : #'as yet unclassified' }
SBBlock >> shownColor [

	| ref col |
	ref := self.
	[(col := ref drawnColor) alpha < 0.7 and: [ref parentSandblock notNil]] whileTrue: [ref := ref parentSandblock].
	^ col
]

{ #category : #testing }
SBBlock >> skipLeftRightNavigation [

	^ false
]

{ #category : #actions }
SBBlock >> slurp [
	<action>
	<actionValidIf: #dynamicNumberOfChildren>

	(self adjacentBlock: 1) ifNotNil: [:block | 
		self sandblockEditor do: (self insertCommandRequest: block near: self childSandblocks last before: false).
		self select]
]

{ #category : #actions }
SBBlock >> slurpFront [
	<action>
	<actionValidIf: #dynamicNumberOfChildren>

	(self adjacentBlock: -1) ifNotNil: [:block | 
		self sandblockEditor do: (self insertCommandRequest: block near: self childSandblocks last before: true).
		self select]
]

{ #category : #suggestions }
SBBlock >> sortedSuggestions: aCollection for: aString [

	| exactMatches fuzzyMatches list |
	"sort list of provided suggestion strings by putting exact matches first and clamps to maxSuggestions.

NOTE: may mutate aCollection"
	list := (aCollection isKindOf: OrderedCollection)
		ifTrue: [aCollection]
		ifFalse: [OrderedCollection withAll: aCollection].
	
	exactMatches := (Array streamContents: [:stream |
		list removeAllSuchThat: [:sel |
			(sel sandblockBeginsWith: aString)
				ifTrue: [stream nextPut: sel];
				yourself]]) sort: #size ascending.
	fuzzyMatches := (Array streamContents: [:stream |
		list removeAllSuchThat: [:sel |
			(sel sandblockMatch: aString)
				ifTrue: [stream nextPut: sel];
				yourself]]) sort: #size ascending.
	
	^ (Array
		streamContents: [:stream |
			stream nextPutAll: exactMatches.
			stream nextPutAll: fuzzyMatches.
			self suggestAlways ifTrue: [stream nextPutAll: list]]
		limitedTo: self maxSuggestions) withoutDuplicates
]

{ #category : #'ast helpers' }
SBBlock >> sourceString [

	^ String streamContents: [:s | self writeSourceOn: s]
]

{ #category : #layout }
SBBlock >> spaceForSymbols [

	| symbols |
	symbols := self symbols.
	^ {
		(symbols first ifNil: [0] ifNotNil: [self fontToUse widthOfString: symbols first]).
		(symbols second ifNil: [0] ifNotNil: [self fontToUse widthOfString: symbols second])
	}
]

{ #category : #'dropping/grabbing' }
SBBlock >> specialDropCommand: aBlock [

	^ nil
]

{ #category : #'event handling' }
SBBlock >> startDrag: anEvent [

	(SBToggledCode
		comment: 'if the preference is on, we absorb the startDrag events'
		active: 1
		do: {[anEvent yellowButtonPressed and: [SBPreferences rightClickContextMenu]]}) ifTrue: [ | canvas |
		canvas := self sandblockEditor canvas scroller.
		anEvent hand newMouseFocus: canvas.
		^ canvas startDrag: (anEvent transformBy: self transformFromWorld asMatrixTransform2x3 inverseTransformation)].
	
	((self hasDecorator: SBMoveDecorator) not or: [anEvent controlKeyPressed or: [anEvent commandKeyPressed]]) ifTrue: [
		^ self pickUp: anEvent].
	
	super startDrag: anEvent.
	self sandblockEditor select: self
]

{ #category : #'as yet unclassified' }
SBBlock >> startInput [

	(self startInputCommand
		ifNotNil: [self]
		ifNil: [self nextBlockThat: [:m | m startInputCommand notNil]]) ifNotNil: [:m | ((m hasOwner: self) or: [m = self]) ifTrue: [self sandblockEditor startInput: m at: 1 replacingContents: false]]
]

{ #category : #input }
SBBlock >> startInputAt: aNumber replacingContents: aBoolean [

	self currentTextMorph ifNotNil: [ | cmd |
		cmd := SBInputCommand new
			oldMorph: self;
			previousText: self contents;
			yourself.
		aBoolean
			ifTrue: [
				self currentTextMorph
					contents: '';
					moveCursorTo: 0]
			ifFalse: [self currentTextMorph moveCursorTo: aNumber].
		
		(self suggestAlways and: [aBoolean not]) ifTrue: [self queueUpdateSuggestionsFocused: self isOneStatementPerArtefact].
		
		^ cmd].
	
	^ nil
]

{ #category : #actions }
SBBlock >> startInputAtEnd [
	<action>

	(self startInputCommand
		ifNotNil: [self]
		ifNil: [self lastMorphThat: [:b | b isSandblock and: [b startInputCommand notNil]]])
		ifNotNil: [:b |
			self sandblockEditor
				startInput: b
				at: 900000000
				replacingContents: false
				in: b textMorphs last]
		ifNil: [
			self lastDeepChild select.
			" try and move into an insert position "
			self sandblockEditor performForSelection: #moveCursorSmaller]
]

{ #category : #actions }
SBBlock >> startInputAtStart [
	<action>

	self sandblockEditor startInput: self at: 1 replacingContents: false
]

{ #category : #input }
SBBlock >> startInputCommand [

	^ self currentTextMorph ifNotNil: [
		SBInputCommand new
			oldMorph: self;
			previousText: self currentTextMorph contents;
			yourself]
]

{ #category : #input }
SBBlock >> startInputCommandIn: aTextMorph [

	^ self startInputCommand
]

{ #category : #actions }
SBBlock >> startInputSubstituting [
	<action>

	self sandblockEditor startInput: self at: 1 replacingContents: true
]

{ #category : #'as yet unclassified' }
SBBlock >> startInsertAtEnd [

	(self sandblockEditor cursor lastInsertPosition: self) ifNotNil: [:last | self sandblockEditor cursor cursorPosition: last explicitMove: true axis: #none]
]

{ #category : #'as yet unclassified' }
SBBlock >> startInsertAtStart [

	(self sandblockEditor cursor firstInsertPosition: self) ifNotNil: [:last | self sandblockEditor cursor cursorPosition: last explicitMove: true axis: #none]
]

{ #category : #'as yet unclassified' }
SBBlock >> startNextInput [

	self inputContainedUnknown ifFalse: [(self cursorPositionInSelfOrAfterThat: [:m | m isText]) ifNotNil: [:pos | self sandblockEditor cursorPosition: pos]]
]

{ #category : #actions }
SBBlock >> startOrAddToMultiSelection [
	<multiSelectAction>

	self sandblockEditor cursor startOrAddToMultiSelection: self
]

{ #category : #input }
SBBlock >> stopEditing: aCommand [

	aCommand
		newText: aCommand textMorph contents;
		newMorph: self.
	
	aCommand textMorph stopEditing.
	self removeSuggestionMenu
]

{ #category : #accessing }
SBBlock >> suggestAlways [

	^ (self sandblockEditor ifNotNil: [:e | e suggestAlways] ifNil: [false]) or: [self grammarHandler ifNotNil: [:g | (g suggestionsFor: self) notEmpty] ifNil: [false]]
]

{ #category : #suggestions }
SBBlock >> suggestions [

	^ self grammarHandler ifNotNil: [:g | g suggestionsFor: self] ifNil: [#()]
]

{ #category : #'as yet unclassified' }
SBBlock >> survivesReload [
	
	^ false
]

{ #category : #'action helpers' }
SBBlock >> swap: aNumber [

	| next children offset canSwap |
	self
		example: ['3 + 4' parseInMethod receiver]
		args: [{1}]
		label: 'example'
		assert: [[:o | o parentSandblock receiver contents = '4']].
	children := self parentSandblock childSandblocks.
	offset := aNumber.
	
	canSwap := [:a :b | (a satisfies: b objectInterface) and: [b satisfies: a objectInterface]].
	[offset abs <= children size and: [(canSwap value: self value: (next := children atWrap: (children indexOf: self) + offset)) not]] whileTrue: [offset := offset + aNumber].
	offset = children size ifTrue: [^ self].
	
	self sandblockEditor do: (SBSwapCommand new
		selectAfter: #block;
		a: self;
		b: next)
]

{ #category : #actions }
SBBlock >> swapLeft [
	<action>
	<inputAction>

	self swap: -1
]

{ #category : #actions }
SBBlock >> swapRight [
	<action>
	<inputAction>

	self swap: 1
]

{ #category : #'colors and color policies' }
SBBlock >> symbols [

	^ #(nil nil)
]

{ #category : #accessing }
SBBlock >> textContents [

	^ self currentTextMorph ifNotNil: [:t | t contents] ifNil: ['']
]

{ #category : #accessing }
SBBlock >> textContentsForCopy [

	^ self textContentsForCopyPreferQuick: false
]

{ #category : #accessing }
SBBlock >> textContentsForCopyPreferQuick: aBoolean [

	^ ((self respondsTo: #prettySourceString) and: [aBoolean not])
		ifTrue: [self prettySourceString]
		ifFalse: [
			(self respondsTo: #writeSourceOn:)
				ifTrue: [self sourceString]
				ifFalse: [self textContents]]
]

{ #category : #accessing }
SBBlock >> textMorphs [

	^ self currentTextMorph ifNil: [{}] ifNotNil: [:t | {t}]
]

{ #category : #actions }
SBBlock >> toggleCollapsed [
	<action>

	self isArtefact ifFalse: [
		self containingArtefact ifNotNil: #toggleCollapsed]
]

{ #category : #decorators }
SBBlock >> toggleDecorator: aDecorator [

	^ decorators
		detect: [:d | d class = aDecorator class]
		ifFound: [:d | self detachDecorator: d]
		ifNone: [self attachDecorator: aDecorator]
]

{ #category : #'ast helpers' }
SBBlock >> tryFixIfFail: aBlock [

	self sandblockEditor select: self.
	self fixActions
		ifNotEmpty: [:actions | self proposeCodeActions: actions for: self].
	^ self valid ifTrue: [true] ifFalse: aBlock
]

{ #category : #replacements }
SBBlock >> tryReplacements [

	
]

{ #category : #'artefact protocol' }
SBBlock >> typeFor: aBlock [

	^ nil
]

{ #category : #'event handling' }
SBBlock >> update [
]

{ #category : #decorators }
SBBlock >> updateSteppingDecorators [

	self decorators do: [:d | d stepTime >= 0 ifTrue: [self world ifNotNil: [:w | (w isStepping: d) ifFalse: [w startStepping: d at: Time millisecondClockValue selector: #step arguments: {} stepTime: d stepTime]]]]
]

{ #category : #suggestions }
SBBlock >> updateSuggestions [

	| editor menu |
	editor := self sandblockEditor ifNil: [^ self].
	menu := editor suggestionMenu.
	self isSelected ifFalse: [
		self hasSuggestions ifTrue: [menu delete].
		^ self].
	
	self shouldSuggest ifFalse: [^ self].
	
	self suggestions
		ifNotEmpty: [:s |
			menu suggestions: (s take: self maxSuggestions).
			menu openNear: self]
		ifEmpty: [
			menu
				suggestions: #();
				delete]
]

{ #category : #layout }
SBBlock >> useAlgebraLayout [

	self
		vResizing: #shrinkWrap;
		hResizing: #rigid;
		layoutPolicy: SBAlgebraLayout new
]

{ #category : #suggestions }
SBBlock >> useSuggestion: anItem [

	self activeTextMorph contents: anItem contents.
	self containingSandblock sandblockEditor ifNotNil: #endInput
]

{ #category : #testing }
SBBlock >> valid [

	^ true
]

{ #category : #'action helpers' }
SBBlock >> validActions [

	| mode |
	mode := self sandblockEditor mode.
	^ self actions select: [:action | self isValidAction: action]
]

{ #category : #testing }
SBBlock >> validSubtree [

	self allBlocksDo: [:b | b valid ifFalse: [^ false]].
	^ true
]

{ #category : #copying }
SBBlock >> veryDeepCopyWith: aCopier [

	| new previousDecorators hover |
	SBToggledCode comment: '' active: 0 do: {
		[
			oldActions := self valueOfProperty: #actionMap.
			self removeProperty: #actionMap]}.
	
	hover := self
		withDecorator: SBHoverDecorator
		do: [:d |
			self detachDecorator: d.
			d]
		ifAbsent: [nil].
	
	new := super veryDeepCopyWith: aCopier.
	hover ifNotNil: [self attachDecorator: hover].
	
	SBToggledCode comment: '' active: 0 do: {[self setProperty: #actionMap toValue: oldActions]}.
	previousDecorators := new decorators copy.
	previousDecorators do: #detach.
	previousDecorators do: [:decorator | new attachDecorator: decorator].
	new currentTextMorph ifNotNil: #stopEditing.
	^ new
]

{ #category : #'colors and color policies' }
SBBlock >> wantsExtraSpace [

	^ true
]

{ #category : #'artefact protocol' }
SBBlock >> wantsInteractiveErrorCorrection [

	^ false
]

{ #category : #'as yet unclassified' }
SBBlock >> wantsMethodBody [

	^ self isArtefact
]

{ #category : #callbacks }
SBBlock >> wasDeselected [

	self removeSuggestionMenu
]

{ #category : #callbacks }
SBBlock >> wasSelected [
	" may be overriden "

	self triggerEvent: #selected.
	
	(self sandblockEditor notNil and: [self suggestAlways and: [self sandblockEditor cursor mode ~= #insert]]) ifTrue: [self queueUpdateSuggestionsFocused: self isOneStatementPerArtefact]
]

{ #category : #callbacks }
SBBlock >> wasSelectedFromCursor: aCursorPosition [
	"callback you can override"

	
]

{ #category : #decorators }
SBBlock >> withDecorator: aClass do: aBlock [

	^ self withDecorator: aClass do: aBlock ifAbsent: []
]

{ #category : #decorators }
SBBlock >> withDecorator: aClass do: aBlock ifAbsent: anotherBlock [

	^ decorators detect: [:d | d isKindOf: aClass] ifFound: aBlock ifNone: anotherBlock
]

{ #category : #utilities }
SBBlock >> wrapEditor [
	" provide an editor around the object, for use during testing "
	
	SBTest editorFor: self.
	^ self
]

{ #category : #'as yet unclassified' }
SBBlock >> wrapOffscreen: anEditor [
	"wrap a selection container with the visual styles of the given editor, such that e.g. imageForm produces consistent results"

	anEditor newSelectionContainer addMorphBack: self
]

{ #category : #'action helpers' }
SBBlock >> wrapSelectionWith: aSelection [

	self sandblockEditor doMultiSelection: [:selected |
		SBRecordedCommand new record: [:recorder | | new adapted adaptedInner |
			new := aSelection.
			adaptedInner := recorder replace: selected first with: new.
			adapted := recorder replace: adaptedInner copyPlaceholder with: selected first.
			recorder moveAll: selected allButFirst after: adapted]]
]

{ #category : #'insert/delete' }
SBBlock >> wrapsAround [

	^ self copyPlaceholder notNil
]
